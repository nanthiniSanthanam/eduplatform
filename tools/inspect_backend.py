#!/usr/bin/env python3

"""
Django Backend Analyzer for Frontend Integration Documentation

This script parses through all backend files in a Django project and extracts
information needed for frontend development. It analyzes models, serializers,
views, URLs, permissions, and other relevant files to produce a comprehensive
report.

The output contains two main sections:
1. FRONTEND DATA - API endpoints, data models, fields, naming conventions, etc.
2. BACKEND COMPATIBILITY - Issues with naming conventions, field mismatches, etc.

Usage:
    python backend_analyzer.py --backend_path /path/to/backend --output_file report.md --output_format markdown

Configuration Variables to Modify:
    - backend_path: Path to your Django backend project root directory (default: current directory)
    - output_file: Path where the output report will be saved (default: backend_analysis_report.md)
    - output_format: 'markdown' (default) or 'json' for the report format
    - verbose: Set to True for detailed logging (default: False)
    - include_code_samples: Whether to include sample code in the report (default: True)
    - max_issues_to_show: Maximum number of issues to include in the report (default: 100)
    - analyze_permissions: Whether to analyze permission classes (default: True)
    - analyze_authentication: Whether to analyze authentication mechanisms (default: True)
    - analyze_settings: Whether to analyze Django settings (default: True)
    - exclude_apps: List of app names to exclude from analysis (default: [])
    - known_project_patterns: Dictionary of custom project patterns to search for (default: {})
    - naming_conventions: Dictionary of expected naming conventions (default standard Django conventions)

Dependencies:
    - Python 3.6+
    - markdown (for HTML output): pip install markdown
    - tabulate (for table formatting): pip install tabulate
    - colorama (for colored terminal output): pip install colorama

Notes:
    - The script attempts to understand your project structure without modifications
    - For larger projects, analysis may take a few minutes
    - For more accurate results, ensure all imports are properly defined in your project
    - The script doesn't execute any of your code, just analyzes the source files
    - To exclude certain apps from analysis, use the --exclude_apps argument

Author: Generated by GitHub Copilot
Date: 2025-04-29
Version: 1.0
"""

import os
import re
import ast
import json
import argparse
import inspect
from collections import defaultdict
from typing import Dict, List, Set, Tuple, Any, Optional
import importlib.util
import sys
from pathlib import Path
import markdown
from tabulate import tabulate
from colorama import Fore, Style, init

# Initialize colorama for colored terminal output
init()

class ModelField:
    """Represents a field in a Django model"""
    def __init__(self, name, field_type, options=None):
        self.name = name
        self.field_type = field_type
        self.options = options or {}

    def __str__(self):
        return f"{self.name}: {self.field_type}"

    def to_dict(self):
        return {
            "name": self.name,
            "field_type": self.field_type,
            "options": self.options
        }

class ModelInfo:
    """Information about a Django model"""
    def __init__(self, name, app_name, fields=None, relationships=None, meta=None):
        self.name = name
        self.app_name = app_name
        self.fields = fields or []
        self.relationships = relationships or []
        self.meta = meta or {}

    def __str__(self):
        return f"{self.app_name}.{self.name}"

    def to_dict(self):
        return {
            "name": self.name,
            "app_name": self.app_name,
            "fields": [f.to_dict() for f in self.fields],
            "relationships": self.relationships,
            "meta": self.meta
        }

class SerializerInfo:
    """Information about a Django REST Framework serializer"""
    def __init__(self, name, model=None, fields=None, meta=None):
        self.name = name
        self.model = model
        self.fields = fields or []
        self.meta = meta or {}

    def __str__(self):
        return f"{self.name} → {self.model}" if self.model else self.name

    def to_dict(self):
        return {
            "name": self.name,
            "model": self.model,
            "fields": self.fields,
            "meta": self.meta
        }

class ViewInfo:
    """Information about a Django view or viewset"""
    def __init__(self, name, view_type, model=None, serializer=None, methods=None, permissions=None):
        self.name = name
        self.view_type = view_type  # APIView, ViewSet, ModelViewSet, etc.
        self.model = model
        self.serializer = serializer
        self.methods = methods or []
        self.permissions = permissions or []

    def __str__(self):
        return f"{self.name} ({self.view_type})"

    def to_dict(self):
        return {
            "name": self.name,
            "view_type": self.view_type,
            "model": self.model,
            "serializer": self.serializer,
            "methods": self.methods,
            "permissions": self.permissions
        }

class URLInfo:
    """Information about a Django URL pattern"""
    def __init__(self, pattern, view, name=None):
        self.pattern = pattern
        self.view = view
        self.name = name

    def __str__(self):
        return f"{self.pattern} → {self.view} ({self.name})" if self.name else f"{self.pattern} → {self.view}"

    def to_dict(self):
        return {
            "pattern": self.pattern,
            "view": self.view,
            "name": self.name
        }

class APIEndpoint:
    """Represents an API endpoint derived from URLs and views"""
    def __init__(self, path, method, view, name=None, model=None, serializer=None, permissions=None):
        self.path = path
        self.method = method
        self.view = view
        self.name = name
        self.model = model
        self.serializer = serializer
        self.permissions = permissions or []

    def __str__(self):
        return f"{self.method} {self.path} → {self.view}"

    def to_dict(self):
        return {
            "path": self.path,
            "method": self.method,
            "view": self.view,
            "name": self.name,
            "model": self.model,
            "serializer": self.serializer,
            "permissions": self.permissions
        }

class CompatibilityIssue:
    """Represents a compatibility issue between frontend and backend"""
    def __init__(self, issue_type, description, severity="warning", file=None, line=None):
        self.issue_type = issue_type  # naming, field_mismatch, serializer_model, etc.
        self.description = description
        self.severity = severity  # info, warning, error
        self.file = file
        self.line = line

    def __str__(self):
        return f"[{self.severity.upper()}] {self.issue_type}: {self.description}"

    def to_dict(self):
        return {
            "issue_type": self.issue_type,
            "description": self.description,
            "severity": self.severity,
            "file": self.file,
            "line": self.line
        }

class BackendAnalyzer:
    """Main analyzer class for Django backend"""

    def __init__(self, backend_path, verbose=False):
        self.backend_path = os.path.abspath(backend_path)
        self.verbose = verbose
        
        # Data structures to store analysis results
        self.apps = set()
        self.models = {}  # app_name.model_name -> ModelInfo
        self.serializers = {}  # app_name.serializer_name -> SerializerInfo
        self.views = {}  # app_name.view_name -> ViewInfo
        self.urls = {}  # app_name -> List[URLInfo]
        self.api_endpoints = []  # List of APIEndpoint objects
        self.issues = []  # List of CompatibilityIssue objects
        
        # Map to track relationships between different components
        self.model_to_serializers = defaultdict(list)
        self.serializer_to_views = defaultdict(list)
        self.view_to_urls = defaultdict(list)
        
        # Dictionary mapping viewset actions to HTTP methods
        self.viewset_action_map = {
            'list': 'GET',
            'retrieve': 'GET',
            'create': 'POST',
            'update': 'PUT',
            'partial_update': 'PATCH',
            'destroy': 'DELETE'
        }
        
        # Add backend path to sys.path to help with imports
        sys.path.insert(0, self.backend_path)

    def log(self, message, level="info"):
        """Print log messages based on verbosity and level"""
        if self.verbose:
            color = {
                "info": Fore.BLUE,
                "success": Fore.GREEN,
                "warning": Fore.YELLOW,
                "error": Fore.RED
            }.get(level, Fore.WHITE)
            
            print(f"{color}[{level.upper()}] {message}{Style.RESET_ALL}")

    def find_django_apps(self):
        """Find all Django apps in the backend directory"""
        self.log("Searching for Django apps...")
        
        for root, dirs, files in os.walk(self.backend_path):
            # Look for apps.py which indicates a Django app
            if 'apps.py' in files:
                app_path = os.path.relpath(root, self.backend_path)
                app_name = os.path.basename(app_path)
                self.apps.add(app_name)
                self.log(f"Found Django app: {app_name}", "success")
                
        self.log(f"Total Django apps found: {len(self.apps)}")
        return self.apps

    def analyze_models(self):
        """Analyze models.py files in all Django apps"""
        self.log("Analyzing Django models...")
        
        for app_name in self.apps:
            models_path = os.path.join(self.backend_path, app_name, 'models.py')
            
            if not os.path.exists(models_path):
                self.log(f"No models.py found for app: {app_name}", "warning")
                continue
                
            self.log(f"Processing models in: {app_name}")
            
            try:
                with open(models_path, 'r') as f:
                    file_content = f.read()
                
                # Parse the AST tree
                tree = ast.parse(file_content)
                
                # Find model classes (subclasses of models.Model)
                for node in ast.walk(tree):
                    if isinstance(node, ast.ClassDef):
                        # Check if it's a model class
                        is_model = False
                        for base in node.bases:
                            if isinstance(base, ast.Name) and base.id == 'Model':
                                is_model = True
                            elif isinstance(base, ast.Attribute) and base.attr == 'Model':
                                is_model = True
                        
                        if is_model:
                            model_name = node.name
                            model_info = self._extract_model_info(node, app_name)
                            self.models[f"{app_name}.{model_name}"] = model_info
                            self.log(f"  Found model: {model_name} with {len(model_info.fields)} fields", "success")
            
            except Exception as e:
                self.log(f"Error analyzing models in {app_name}: {str(e)}", "error")
        
        self.log(f"Total models found: {len(self.models)}")
        return self.models

    def _extract_model_info(self, node, app_name):
        """Extract information from a model class node"""
        model_name = node.name
        fields = []
        relationships = []
        meta = {}
        
        for item in node.body:
            # Extract field definitions
            if isinstance(item, ast.Assign):
                for target in item.targets:
                    if isinstance(target, ast.Name):
                        field_name = target.id
                        field_type, options = self._extract_field_info(item.value)
                        
                        # Identify relationships
                        if field_type in ['ForeignKey', 'OneToOneField', 'ManyToManyField']:
                            try:
                                related_model = options.get('to', '')
                                if not related_model:
                                    # Try to extract from first arg
                                    if isinstance(item.value, ast.Call) and item.value.args:
                                        if isinstance(item.value.args[0], ast.Str):
                                            related_model = item.value.args[0].s
                                        elif isinstance(item.value.args[0], ast.Name):
                                            related_model = item.value.args[0].id
                                
                                relationships.append({
                                    'field_name': field_name,
                                    'relation_type': field_type,
                                    'related_model': related_model,
                                    'related_name': options.get('related_name', None)
                                })
                            except Exception as e:
                                self.log(f"Error parsing relationship {field_name}: {str(e)}", "error")
                        
                        fields.append(ModelField(field_name, field_type, options))
            
            # Extract Meta class information
            elif isinstance(item, ast.ClassDef) and item.name == 'Meta':
                for meta_item in item.body:
                    if isinstance(meta_item, ast.Assign) and isinstance(meta_item.targets[0], ast.Name):
                        meta_name = meta_item.targets[0].id
                        meta_value = self._extract_meta_value(meta_item.value)
                        meta[meta_name] = meta_value
        
        return ModelInfo(model_name, app_name, fields, relationships, meta)

    def _extract_field_info(self, node):
        """Extract field type and options from a field definition"""
        field_type = None
        options = {}
        
        if isinstance(node, ast.Call):
            # Get field type
            if isinstance(node.func, ast.Name):
                field_type = node.func.id
            elif isinstance(node.func, ast.Attribute):
                field_type = node.func.attr
            
            # Get field options
            for keyword in node.keywords:
                if isinstance(keyword.value, ast.Str):
                    options[keyword.arg] = keyword.value.s
                elif isinstance(keyword.value, ast.Num):
                    options[keyword.arg] = keyword.value.n
                elif isinstance(keyword.value, ast.NameConstant):  # True, False, None
                    options[keyword.arg] = keyword.value.value
                elif isinstance(keyword.value, ast.List):
                    options[keyword.arg] = "list"
                elif isinstance(keyword.value, ast.Dict):
                    options[keyword.arg] = "dict"
                elif isinstance(keyword.value, ast.Name):
                    options[keyword.arg] = keyword.value.id
        
        return field_type or "Unknown", options

    def _extract_meta_value(self, node):
        """Extract meta value from a node"""
        if isinstance(node, ast.Str):
            return node.s
        elif isinstance(node, ast.Num):
            return node.n
        elif isinstance(node, ast.List):
            return "list"
        elif isinstance(node, ast.Tuple):
            return "tuple"
        elif isinstance(node, ast.Name):
            return node.id
        elif isinstance(node, ast.NameConstant):
            return node.value
        else:
            return str(type(node).__name__)

    def analyze_serializers(self):
        """Analyze serializers.py files in all Django apps"""
        self.log("Analyzing Django REST Framework serializers...")
        
        for app_name in self.apps:
            serializers_path = os.path.join(self.backend_path, app_name, 'serializers.py')
            
            if not os.path.exists(serializers_path):
                self.log(f"No serializers.py found for app: {app_name}", "warning")
                continue
                
            self.log(f"Processing serializers in: {app_name}")
            
            try:
                with open(serializers_path, 'r') as f:
                    file_content = f.read()
                
                # Parse the AST tree
                tree = ast.parse(file_content)
                
                # Find serializer classes (subclasses of serializers.*)
                for node in ast.walk(tree):
                    if isinstance(node, ast.ClassDef):
                        # Check if it's a serializer class
                        is_serializer = False
                        for base in node.bases:
                            if isinstance(base, ast.Name) and 'Serializer' in base.id:
                                is_serializer = True
                            elif isinstance(base, ast.Attribute) and 'Serializer' in base.attr:
                                is_serializer = True
                        
                        if is_serializer:
                            serializer_name = node.name
                            serializer_info = self._extract_serializer_info(node, app_name)
                            self.serializers[f"{app_name}.{serializer_name}"] = serializer_info
                            
                            # Update model to serializer mapping
                            if serializer_info.model:
                                self.model_to_serializers[serializer_info.model].append(f"{app_name}.{serializer_name}")
                            
                            self.log(f"  Found serializer: {serializer_name}", "success")
            
            except Exception as e:
                self.log(f"Error analyzing serializers in {app_name}: {str(e)}", "error")
        
        self.log(f"Total serializers found: {len(self.serializers)}")
        return self.serializers

    def _extract_serializer_info(self, node, app_name):
        """Extract information from a serializer class node"""
        serializer_name = node.name
        fields = []
        meta = {}
        model = None
        
        for item in node.body:
            # Extract field definitions
            if isinstance(item, ast.Assign):
                for target in item.targets:
                    if isinstance(target, ast.Name):
                        field_name = target.id
                        fields.append(field_name)
            
            # Extract Meta class information
            elif isinstance(item, ast.ClassDef) and item.name == 'Meta':
                for meta_item in item.body:
                    if isinstance(meta_item, ast.Assign) and isinstance(meta_item.targets[0], ast.Name):
                        meta_name = meta_item.targets[0].id
                        meta_value = self._extract_meta_value(meta_item.value)
                        meta[meta_name] = meta_value
                        
                        # Extract model information
                        if meta_name == 'model':
                            model = meta_value
        
        return SerializerInfo(serializer_name, model, fields, meta)

    def analyze_views(self):
        """Analyze views.py files in all Django apps"""
        self.log("Analyzing Django views...")
        
        for app_name in self.apps:
            views_path = os.path.join(self.backend_path, app_name, 'views.py')
            
            if not os.path.exists(views_path):
                self.log(f"No views.py found for app: {app_name}", "warning")
                continue
                
            self.log(f"Processing views in: {app_name}")
            
            try:
                with open(views_path, 'r') as f:
                    file_content = f.read()
                
                # Parse the AST tree
                tree = ast.parse(file_content)
                
                # Find view classes
                for node in ast.walk(tree):
                    if isinstance(node, ast.ClassDef):
                        view_name = node.name
                        view_type, model, serializer = self._extract_view_type_and_model(node)
                        
                        if view_type:
                            methods, permissions = self._extract_view_methods_and_permissions(node)
                            view_info = ViewInfo(view_name, view_type, model, serializer, methods, permissions)
                            self.views[f"{app_name}.{view_name}"] = view_info
                            
                            # Update serializer to view mapping
                            if serializer:
                                self.serializer_to_views[serializer].append(f"{app_name}.{view_name}")
                            
                            self.log(f"  Found view: {view_name} ({view_type})", "success")
            
            except Exception as e:
                self.log(f"Error analyzing views in {app_name}: {str(e)}", "error")
        
        self.log(f"Total views found: {len(self.views)}")
        return self.views

    def _extract_view_type_and_model(self, node):
        """Extract view type and associated model from a view class node"""
        view_type = None
        model = None
        serializer = None
        
        # Check base classes to determine view type
        for base in node.bases:
            if isinstance(base, ast.Name):
                view_type = base.id
            elif isinstance(base, ast.Attribute):
                view_type = base.attr
        
        # Extract model and serializer from class variables
        for item in node.body:
            if isinstance(item, ast.Assign) and isinstance(item.targets[0], ast.Name):
                var_name = item.targets[0].id
                
                if var_name == 'queryset' and isinstance(item.value, ast.Call):
                    # Extract model from queryset = Model.objects.all()
                    if isinstance(item.value.func, ast.Attribute) and item.value.func.attr == 'all':
                        if isinstance(item.value.func.value, ast.Attribute) and item.value.func.value.attr == 'objects':
                            if isinstance(item.value.func.value.value, ast.Name):
                                model = item.value.func.value.value.id
                
                elif var_name == 'model' and isinstance(item.value, ast.Name):
                    # Extract model from model = ModelName
                    model = item.value.id
                
                elif var_name == 'serializer_class' and isinstance(item.value, ast.Name):
                    # Extract serializer from serializer_class = SerializerName
                    serializer = item.value.id
        
        return view_type, model, serializer

    def _extract_view_methods_and_permissions(self, node):
        """Extract HTTP methods and permissions from a view class node"""
        methods = []
        permissions = []
        
        for item in node.body:
            # Extract methods defined in the class
            if isinstance(item, ast.FunctionDef):
                method_name = item.name.lower()
                if method_name in ['get', 'post', 'put', 'patch', 'delete', 'head', 'options']:
                    methods.append(method_name.upper())
            
            # Extract permissions
            if isinstance(item, ast.Assign) and isinstance(item.targets[0], ast.Name):
                var_name = item.targets[0].id
                
                if var_name == 'permission_classes':
                    if isinstance(item.value, ast.List):
                        for element in item.value.elts:
                            if isinstance(element, ast.Name):
                                permissions.append(element.id)
                            elif isinstance(element, ast.Attribute):
                                permissions.append(element.attr)
        
        return methods, permissions

    def analyze_urls(self):
        """Analyze urls.py files in all Django apps and root URLs"""
        self.log("Analyzing Django URLs...")
        
        # First check for root URLs
        root_urls_path = self._find_root_urls_path()
        if root_urls_path:
            self.log(f"Processing root URLs: {root_urls_path}")
            self._process_urls_file(root_urls_path, "root")
        
        # Then check app-specific URLs
        for app_name in self.apps:
            urls_path = os.path.join(self.backend_path, app_name, 'urls.py')
            
            if not os.path.exists(urls_path):
                self.log(f"No urls.py found for app: {app_name}", "warning")
                continue
                
            self.log(f"Processing URLs in: {app_name}")
            self._process_urls_file(urls_path, app_name)
        
        # Count total URLs
        total_urls = sum(len(urls) for urls in self.urls.values())
        self.log(f"Total URL patterns found: {total_urls}")
        return self.urls

    def _find_root_urls_path(self):
        """Find the root urls.py file"""
        # Try to find the Django project's root directory
        # This is typically a directory with settings.py
        for root, dirs, files in os.walk(self.backend_path):
            if 'settings.py' in files:
                project_dir = os.path.basename(root)
                urls_path = os.path.join(root, 'urls.py')
                
                if os.path.exists(urls_path):
                    return urls_path
        
        return None

    def _process_urls_file(self, urls_path, app_name):
        """Process a urls.py file to extract URL patterns"""
        try:
            with open(urls_path, 'r') as f:
                file_content = f.read()
            
            # Use regex to extract URL patterns
            # This is a simpler approach than parsing the AST for URL patterns
            
            # Look for path() or re_path() or url() patterns
            pattern_regex = r'(?:path|re_path|url)\s*\(\s*[\'"]([^\'"]*)[\'"],\s*([^,)]+)(?:,\s*name\s*=\s*[\'"]([^\'"]*)[\'"])?'
            matches = re.findall(pattern_regex, file_content)
            
            url_patterns = []
            for match in matches:
                pattern, view, name = match
                
                # Clean up the pattern
                pattern = pattern.replace('\\', '')
                
                # Clean up the view reference
                view = view.strip()
                
                # Create URLInfo object
                url_info = URLInfo(pattern, view, name)
                url_patterns.append(url_info)
                
                # Update the URL data structure
                if app_name not in self.urls:
                    self.urls[app_name] = []
                
                self.urls[app_name].append(url_info)
                
                # Update view to URL mapping
                view_name = self._extract_view_name_from_reference(view)
                if view_name:
                    self.view_to_urls[view_name].append(url_info)
                
                self.log(f"  Found URL pattern: {pattern} → {view}", "success")
            
            # Look for include() statements
            include_regex = r'include\s*\(\s*[\'"]([^\'"]+)[\'"]'
            include_matches = re.findall(include_regex, file_content)
            
            for include_path in include_matches:
                self.log(f"  Found include: {include_path}", "info")
        
        except Exception as e:
            self.log(f"Error analyzing URLs in {app_name}: {str(e)}", "error")

    def _extract_view_name_from_reference(self, view_ref):
        """Extract the view name from a view reference in urls.py"""
        # Handle common patterns like 'views.ViewName.as_view()'
        if '.as_view()' in view_ref:
            view_ref = view_ref.replace('.as_view()', '')
        
        # Handle 'app_name.views.ViewName' pattern
        parts = view_ref.split('.')
        if len(parts) > 1:
            return parts[-1]
        
        return view_ref

    def identify_api_endpoints(self):
        """Identify API endpoints by combining URL, view, and serializer information"""
        self.log("Identifying API endpoints...")
        
        for app_name, url_patterns in self.urls.items():
            for url_info in url_patterns:
                view_name = self._extract_view_name_from_reference(url_info.view)
                
                # Try to find the matching view
                view_full_name = None
                for key in self.views.keys():
                    if key.endswith('.' + view_name):
                        view_full_name = key
                        break
                
                if view_full_name:
                    view_info = self.views[view_full_name]
                    
                    # For ViewSet or ModelViewSet, create multiple endpoints
                    if 'ViewSet' in view_info.view_type:
                        for action, method in self.viewset_action_map.items():
                            # Construct appropriate path based on action
                            path = url_info.pattern
                            if action == 'list':
                                path = path.rstrip('/')
                            elif action == 'retrieve':
                                if not path.endswith('/'):
                                    path += '/'
                                path += '<id>/'
                            elif action in ['update', 'partial_update', 'destroy']:
                                if not path.endswith('/'):
                                    path += '/'
                                path += '<id>/'
                            
                            endpoint = APIEndpoint(
                                path=path,
                                method=method,
                                view=view_info.name,
                                name=f"{url_info.name}_{action}" if url_info.name else None,
                                model=view_info.model,
                                serializer=view_info.serializer,
                                permissions=view_info.permissions
                            )
                            self.api_endpoints.append(endpoint)
                            self.log(f"  Identified API endpoint: {method} {path}", "success")
                    
                    # For regular views, use the methods defined in the view
                    else:
                        for method in (view_info.methods or ['GET']):
                            endpoint = APIEndpoint(
                                path=url_info.pattern,
                                method=method,
                                view=view_info.name,
                                name=url_info.name,
                                model=view_info.model,
                                serializer=view_info.serializer,
                                permissions=view_info.permissions
                            )
                            self.api_endpoints.append(endpoint)
                            self.log(f"  Identified API endpoint: {method} {url_info.pattern}", "success")
                
                # If view not found but URL exists, add a placeholder
                elif not view_full_name:
                    endpoint = APIEndpoint(
                        path=url_info.pattern,
                        method="GET",  # Default method
                        view=url_info.view,
                        name=url_info.name
                    )
                    self.api_endpoints.append(endpoint)
                    self.log(f"  Identified API endpoint (view not found): GET {url_info.pattern}", "warning")
        
        self.log(f"Total API endpoints identified: {len(self.api_endpoints)}")
        return self.api_endpoints

    def analyze_permissions(self):
        """Analyze permission classes"""
        self.log("Analyzing permission classes...")
        
        permission_files = []
        for app_name in self.apps:
            permissions_path = os.path.join(self.backend_path, app_name, 'permissions.py')
            
            if os.path.exists(permissions_path):
                permission_files.append((app_name, permissions_path))
                self.log(f"Found permissions.py in {app_name}")
        
        # If no specific permission files, look in views.py
        if not permission_files:
            self.log("No dedicated permission files found, using permissions from views", "warning")
            
            # Collect unique permissions
            unique_permissions = set()
            for view_info in self.views.values():
                unique_permissions.update(view_info.permissions)
            
            self.log(f"Found {len(unique_permissions)} unique permission classes in views")
        
        # TODO: Add more detailed permission analysis if needed
        
        return permission_files

    def detect_compatibility_issues(self):
        """Detect compatibility issues between models, serializers, views, and URLs"""
        self.log("Detecting compatibility issues...")
        
        # Check 1: Models referenced by serializers should exist
        for serializer_name, serializer_info in self.serializers.items():
            if serializer_info.model:
                # Build possible model references
                found = False
                for model_key in self.models.keys():
                    if model_key.endswith('.' + serializer_info.model):
                        found = True
                        break
                
                if not found:
                    self.issues.append(CompatibilityIssue(
                        issue_type="serializer_model_mismatch",
                        description=f"Serializer {serializer_name} references model {serializer_info.model} which was not found",
                        severity="error"
                    ))
        
        # Check 2: Serializers referenced by views should exist
        for view_name, view_info in self.views.items():
            if view_info.serializer:
                # Build possible serializer references
                found = False
                for serializer_key in self.serializers.keys():
                    if serializer_key.endswith('.' + view_info.serializer):
                        found = True
                        break
                
                if not found:
                    self.issues.append(CompatibilityIssue(
                        issue_type="view_serializer_mismatch",
                        description=f"View {view_name} references serializer {view_info.serializer} which was not found",
                        severity="error"
                    ))
        
        # Check 3: Views referenced by URLs should exist
        for app_name, url_list in self.urls.items():
            for url_info in url_list:
                view_name = self._extract_view_name_from_reference(url_info.view)
                
                # Skip function views, this analysis focuses on class-based views
                if '.' not in url_info.view and not any(view_name == v.name for v in self.views.values()):
                    continue
                
                # Build possible view references
                found = False
                for view_key in self.views.keys():
                    if view_key.endswith('.' + view_name):
                        found = True
                        break
                
                if not found:
                    self.issues.append(CompatibilityIssue(
                        issue_type="url_view_mismatch",
                        description=f"URL {url_info.pattern} references view {view_name} which was not found",
                        severity="error"
                    ))
        
        # Check 4: Naming conventions
        for model_key, model_info in self.models.items():
            # Model names should be singular and PascalCase
            if not model_info.name[0].isupper():
                self.issues.append(CompatibilityIssue(
                    issue_type="naming_convention",
                    description=f"Model {model_info.name} should use PascalCase (start with uppercase)",
                    severity="warning"
                ))
        
        for serializer_key, serializer_info in self.serializers.items():
            # Serializer names should end with 'Serializer'
            if not serializer_info.name.endswith('Serializer'):
                self.issues.append(CompatibilityIssue(
                    issue_type="naming_convention",
                    description=f"Serializer {serializer_info.name} should end with 'Serializer'",
                    severity="warning"
                ))
        
        # Check for model/serializer field mismatches
        for serializer_name, serializer_info in self.serializers.items():
            if serializer_info.model:
                # Find the corresponding model
                model_info = None
                for model_key, m_info in self.models.items():
                    if model_key.endswith('.' + serializer_info.model):
                        model_info = m_info
                        break
                
                if model_info:
                    # Check if all fields in serializer meta exist in model
                    model_field_names = set(field.name for field in model_info.fields)
                    serializer_fields = serializer_info.meta.get('fields', [])
                    
                    if serializer_fields != "list" and serializer_fields != "__all__":
                        for field in serializer_fields:
                            if field not in model_field_names and field != 'id':
                                self.issues.append(CompatibilityIssue(
                                    issue_type="field_mismatch",
                                    description=f"Serializer {serializer_info.name} references field '{field}' which does not exist in model {model_info.name}",
                                    severity="error"
                                ))
        
        self.log(f"Found {len(self.issues)} compatibility issues")
        return self.issues

    def analyze_settings(self):
        """Analyze Django settings.py for important configurations"""
        self.log("Analyzing Django settings...")
        
        settings_data = {}
        
        # Find settings.py
        settings_path = None
        for root, dirs, files in os.walk(self.backend_path):
            if 'settings.py' in files:
                settings_path = os.path.join(root, 'settings.py')
                break
        
        if not settings_path:
            self.log("settings.py not found", "error")
            return settings_data
        
        try:
            with open(settings_path, 'r') as f:
                file_content = f.read()
            
            # Parse the AST tree
            tree = ast.parse(file_content)
            
            # Extract important settings
            for node in ast.walk(tree):
                if isinstance(node, ast.Assign) and isinstance(node.targets[0], ast.Name):
                    var_name = node.targets[0].id
                    
                    # Check for important settings
                    if var_name in [
                        'INSTALLED_APPS', 'REST_FRAMEWORK', 'DATABASES', 
                        'MIDDLEWARE', 'CORS_ALLOWED_ORIGINS', 'CORS_ALLOW_ALL_ORIGINS',
                        'ALLOWED_HOSTS', 'DEBUG', 'STATIC_URL', 'MEDIA_URL',
                        'AUTHENTICATION_BACKENDS'
                    ]:
                        # Extract the value in a simplified form
                        if isinstance(node.value, ast.List) or isinstance(node.value, ast.Tuple):
                            settings_data[var_name] = [
                                el.s if isinstance(el, ast.Str) else "complex_value" 
                                for el in node.value.elts
                            ]
                        elif isinstance(node.value, ast.Dict):
                            settings_data[var_name] = "dict"
                        elif isinstance(node.value, ast.NameConstant):
                            settings_data[var_name] = node.value.value
                        elif isinstance(node.value, ast.Str):
                            settings_data[var_name] = node.value.s
                        else:
                            settings_data[var_name] = "complex_value"
            
            self.log(f"Found {len(settings_data)} important settings")
        
        except Exception as e:
            self.log(f"Error analyzing settings: {str(e)}", "error")
        
        return settings_data

    def analyze_authentication(self):
        """Analyze authentication mechanism in the project"""
        self.log("Analyzing authentication mechanisms...")
        
        auth_data = {
            'mechanisms': set(),
            'user_model': None,
            'custom_auth': False
        }
        
        # Check settings for authentication backends
        settings_data = self.analyze_settings()
        backends = settings_data.get('AUTHENTICATION_BACKENDS', [])
        
        if backends:
            for backend in backends:
                if isinstance(backend, str):
                    if 'django.contrib.auth' in backend:
                        auth_data['mechanisms'].add('django_auth')
                    if 'allauth' in backend:
                        auth_data['mechanisms'].add('allauth')
                    if 'knox' in backend:
                        auth_data['mechanisms'].add('knox')
                    if 'rest_framework.authentication' in backend:
                        auth_data['mechanisms'].add('drf_auth')
                    if 'dj_rest_auth' in backend:
                        auth_data['mechanisms'].add('dj_rest_auth')
                    if 'oauth2' in backend or 'oauth' in backend:
                        auth_data['mechanisms'].add('oauth')
                    if 'jwt' in backend.lower():
                        auth_data['mechanisms'].add('jwt')
                    if 'social' in backend:
                        auth_data['mechanisms'].add('social_auth')
        
        # Check if settings has REST_FRAMEWORK with authentication classes
        rest_framework = settings_data.get('REST_FRAMEWORK', {})
        if rest_framework == "dict":  # Placeholder for dict value from simplified AST parsing
            auth_data['mechanisms'].add('drf_auth')
        
        # Check installed apps for authentication-related packages
        installed_apps = settings_data.get('INSTALLED_APPS', [])
        for app in installed_apps:
            if isinstance(app, str):
                if 'rest_framework.authtoken' in app:
                    auth_data['mechanisms'].add('drf_token')
                if 'knox' in app:
                    auth_data['mechanisms'].add('knox')
                if 'allauth' in app:
                    auth_data['mechanisms'].add('allauth')
                if 'dj_rest_auth' in app:
                    auth_data['mechanisms'].add('dj_rest_auth')
                if 'oauth2' in app or 'oauth' in app:
                    auth_data['mechanisms'].add('oauth')
                if 'social' in app:
                    auth_data['mechanisms'].add('social_auth')
                if 'jwt' in app.lower():
                    auth_data['mechanisms'].add('jwt')
        
        # Find custom user models
        for app_name in self.apps:
            models_path = os.path.join(self.backend_path, app_name, 'models.py')
            
            if os.path.exists(models_path):
                try:
                    with open(models_path, 'r') as f:
                        file_content = f.read()
                    
                    # Look for AbstractUser or AbstractBaseUser
                    if 'AbstractUser' in file_content or 'AbstractBaseUser' in file_content:
                        # Parse the AST tree
                        tree = ast.parse(file_content)
                        
                        for node in ast.walk(tree):
                            if isinstance(node, ast.ClassDef):
                                for base in node.bases:
                                    if isinstance(base, ast.Name) and base.id in ['AbstractUser', 'AbstractBaseUser']:
                                        auth_data['user_model'] = f"{app_name}.{node.name}"
                                        auth_data['custom_auth'] = True
                                        break
                                    elif isinstance(base, ast.Attribute) and base.attr in ['AbstractUser', 'AbstractBaseUser']:
                                        auth_data['user_model'] = f"{app_name}.{node.name}"
                                        auth_data['custom_auth'] = True
                                        break
                
                except Exception as e:
                    self.log(f"Error checking custom user model in {app_name}: {str(e)}", "error")
        
        # If no custom user model found, assume default
        if not auth_data['user_model']:
            auth_data['user_model'] = "django.contrib.auth.models.User"
        
        # Convert set to list for better serialization
        auth_data['mechanisms'] = list(auth_data['mechanisms'])
        
        self.log(f"Identified authentication mechanisms: {', '.join(auth_data['mechanisms'])}")
        if auth_data['custom_auth']:
            self.log(f"Found custom user model: {auth_data['user_model']}")
        
        return auth_data

    def generate_er_diagram(self):
        """Generate entity-relationship diagram in text format"""
        self.log("Generating entity-relationship diagram...")
        
        er_lines = ["# Entity-Relationship Diagram", ""]
        app_models = {}
        
        # Group models by app
        for model_key, model_info in self.models.items():
            if model_info.app_name not in app_models:
                app_models[model_info.app_name] = []
            
            app_models[model_info.app_name].append(model_info)
        
        # Generate diagram for each app
        for app_name, models in app_models.items():
            er_lines.append(f"## App: {app_name}")
            er_lines.append("```")
            
            # Add each model
            for model_info in models:
                er_lines.append(f"[{model_info.name}]")
                
                # Add fields
                for field in model_info.fields:
                    field_str = f"  {field.name}: {field.field_type}"
                    
                    # Add options if available
                    if field.options:
                        options_str = ", ".join(f"{k}={v}" for k, v in field.options.items())
                        if options_str:
                            field_str += f" ({options_str})"
                    
                    er_lines.append(field_str)
                
                er_lines.append("")
            
            # Add relationships
            er_lines.append("# Relationships")
            for model_info in models:
                for rel in model_info.relationships:
                    rel_type_symbol = {
                        'ForeignKey': '->',
                        'OneToOneField': '--',
                        'ManyToManyField': '<->'
                    }.get(rel['relation_type'], '->')
                    
                    related_name = f" (as {rel['related_name']})" if rel['related_name'] else ""
                    er_lines.append(f"[{model_info.name}] {rel_type_symbol} [{rel['related_model']}] : {rel['field_name']}{related_name}")
            
            er_lines.append("```")
            er_lines.append("")
        
        return "\n".join(er_lines)

    def analyze(self):
        """Run the full analysis"""
        self.log("Starting full backend analysis...")
        
        # Basic project analysis
        self.find_django_apps()
        self.analyze_models()
        self.analyze_serializers()
        self.analyze_views()
        self.analyze_urls()
        self.analyze_permissions()
        self.analyze_settings()
        
        # Identify API endpoints and analyze authentication
        self.identify_api_endpoints()
        auth_data = self.analyze_authentication()
        
        # Detect issues and generate ER diagram
        self.detect_compatibility_issues()
        er_diagram = self.generate_er_diagram()
        
        # Prepare final report data
        analysis_data = {
            'frontend_data': {
                'api_endpoints': [endpoint.to_dict() for endpoint in self.api_endpoints],
                'data_models': {model_name: model.to_dict() for model_name, model in self.models.items()},
                'serializers': {serializer_name: serializer.to_dict() for serializer_name, serializer in self.serializers.items()},
                'er_diagram': er_diagram,
                'authentication': auth_data
            },
            'backend_compatibility': {
                'issues': [issue.to_dict() for issue in self.issues],
                'model_serializer_mapping': dict(self.model_to_serializers),
                'serializer_view_mapping': dict(self.serializer_to_views),
                'view_url_mapping': dict(self.view_to_urls)
            }
        }
        
        self.log("Analysis completed successfully!", "success")
        return analysis_data

    def generate_report(self, analysis_data, output_format='markdown'):
        """Generate a formatted report based on analysis data"""
        self.log(f"Generating {output_format} report...")
        
        if output_format == 'json':
            # Convert defaultdicts to regular dicts for JSON serialization
            for key, value in analysis_data['backend_compatibility'].items():
                if isinstance(value, defaultdict):
                    analysis_data['backend_compatibility'][key] = dict(value)
            
            return json.dumps(analysis_data, indent=2)
        
        elif output_format == 'markdown':
            report_lines = [
                "# Django Backend Analysis Report",
                f"- Generated on: {os.path.basename(self.backend_path)}",
                f"- Date: {self._get_current_date()}",
                "",
                "## Table of Contents",
                "1. [Frontend Data](#frontend-data)",
                "   1. [API Endpoints](#api-endpoints)",
                "   2. [Data Models](#data-models)",
                "   3. [Serializers](#serializers)",
                "   4. [Entity-Relationship Diagram](#entity-relationship-diagram)",
                "   5. [Authentication](#authentication)",
                "2. [Backend Compatibility](#backend-compatibility)",
                "   1. [Issues](#issues)",
                "   2. [Component Mappings](#component-mappings)",
                "",
                "---",
                "",
                "<a id='frontend-data'></a>",
                "# FRONT END DATA",
                "",
                "<a id='api-endpoints'></a>",
                "## API Endpoints",
                "",
            ]
            
            # API Endpoints
            endpoints = analysis_data['frontend_data']['api_endpoints']
            if endpoints:
                report_lines.extend(self._format_api_endpoints(endpoints))
            else:
                report_lines.append("No API endpoints found.")
            
            report_lines.extend([
                "",
                "<a id='data-models'></a>",
                "## Data Models",
                ""
            ])
            
            # Data Models
            models = analysis_data['frontend_data']['data_models']
            if models:
                report_lines.extend(self._format_data_models(models))
            else:
                report_lines.append("No data models found.")
            
            report_lines.extend([
                "",
                "<a id='serializers'></a>",
                "## Serializers",
                ""
            ])
            
            # Serializers
            serializers = analysis_data['frontend_data']['serializers']
            if serializers:
                report_lines.extend(self._format_serializers(serializers))
            else:
                report_lines.append("No serializers found.")
            
            report_lines.extend([
                "",
                "<a id='entity-relationship-diagram'></a>",
                "## Entity-Relationship Diagram",
                ""
            ])
            
            # ER Diagram
            er_diagram = analysis_data['frontend_data']['er_diagram']
            if er_diagram:
                report_lines.append(er_diagram)
            else:
                report_lines.append("No entity-relationship diagram generated.")
            
            report_lines.extend([
                "",
                "<a id='authentication'></a>",
                "## Authentication",
                ""
            ])
            
            # Authentication
            auth_data = analysis_data['frontend_data']['authentication']
            if auth_data:
                report_lines.extend(self._format_authentication(auth_data))
            else:
                report_lines.append("No authentication information found.")
            
            report_lines.extend([
                "",
                "---",
                "",
                "<a id='backend-compatibility'></a>",
                "# BACKEND COMPATIBILITY",
                "",
                "<a id='issues'></a>",
                "## Issues",
                ""
            ])
            
            # Issues
            issues = analysis_data['backend_compatibility']['issues']
            if issues:
                report_lines.extend(self._format_issues(issues))
            else:
                report_lines.append("No compatibility issues found.")
            
            report_lines.extend([
                "",
                "<a id='component-mappings'></a>",
                "## Component Mappings",
                ""
            ])
            
            # Component Mappings
            mappings = {
                'Model to Serializers': analysis_data['backend_compatibility'].get('model_serializer_mapping', {}),
                'Serializer to Views': analysis_data['backend_compatibility'].get('serializer_view_mapping', {}),
                'View to URLs': analysis_data['backend_compatibility'].get('view_url_mapping', {})
            }
            
            report_lines.extend(self._format_component_mappings(mappings))
            
            return "\n".join(report_lines)
        
        else:
            self.log(f"Unsupported output format: {output_format}", "error")
            return "Unsupported output format. Please choose 'json' or 'markdown'."

    def _get_current_date(self):
        """Get current date in ISO format"""
        from datetime import datetime
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def _format_api_endpoints(self, endpoints):
        """Format API endpoints for markdown report"""
        lines = []
        
        # Group endpoints by base path
        endpoints_by_path = defaultdict(list)
        for endpoint in endpoints:
            base_path = endpoint['path'].split('<')[0].rstrip('/')
            endpoints_by_path[base_path].append(endpoint)
        
        for base_path, path_endpoints in endpoints_by_path.items():
            lines.append(f"### Path: `{base_path}`")
            lines.append("")
            
            # Create table for endpoints
            table_headers = ["Method", "Full Path", "View", "Serializer", "Model", "Permissions"]
            table_rows = []
            
            for endpoint in path_endpoints:
                row = [
                    endpoint['method'],
                    f"`{endpoint['path']}`",
                    endpoint['view'],
                    endpoint['serializer'] or '-',
                    endpoint['model'] or '-',
                    ', '.join(endpoint['permissions']) if endpoint['permissions'] else '-'
                ]
                table_rows.append(row)
            
            # Add table
            lines.append("| " + " | ".join(table_headers) + " |")
            lines.append("| " + " | ".join(["---" for _ in table_headers]) + " |")
            for row in table_rows:
                lines.append("| " + " | ".join(row) + " |")
            
            lines.append("")
        
        # Add general REST API conventions
        lines.extend([
            "### Common API Conventions",
            "",
            "- **GET /resource/**: List all resources",
            "- **POST /resource/**: Create a new resource",
            "- **GET /resource/{id}/**: Retrieve a specific resource",
            "- **PUT /resource/{id}/**: Update a specific resource (full update)",
            "- **PATCH /resource/{id}/**: Update a specific resource (partial update)",
            "- **DELETE /resource/{id}/**: Delete a specific resource",
            ""
        ])
        
        return lines

    def _format_data_models(self, models):
        """Format data models for markdown report"""
        lines = []
        
        # Group models by app
        models_by_app = defaultdict(list)
        for model_key, model_data in models.items():
            app_name = model_data['app_name']
            models_by_app[app_name].append(model_data)
        
        for app_name, app_models in models_by_app.items():
            lines.append(f"### App: {app_name}")
            lines.append("")
            
            for model in app_models:
                lines.append(f"#### {model['name']}")
                lines.append("")
                
                # Model metadata
                if model['meta']:
                    meta_items = []
                    for key, value in model['meta'].items():
                        meta_items.append(f"{key}: {value}")
                    if meta_items:
                        lines.append("**Meta Options:**")
                        for item in meta_items:
                            lines.append(f"- {item}")
                        lines.append("")
                
                # Fields table
                lines.append("**Fields:**")
                lines.append("")
                lines.append("| Field Name | Field Type | Options |")
                lines.append("| --- | --- | --- |")
                
                for field in model['fields']:
                    options_str = ", ".join(f"{k}={v}" for k, v in field['options'].items()) if field['options'] else "-"
                    lines.append(f"| {field['name']} | {field['field_type']} | {options_str} |")
                
                lines.append("")
                
                # Relationships
                if model['relationships']:
                    lines.append("**Relationships:**")
                    lines.append("")
                    lines.append("| Field Name | Relation Type | Related Model | Related Name |")
                    lines.append("| --- | --- | --- | --- |")
                    
                    for rel in model['relationships']:
                        related_name = rel['related_name'] or "-"
                        lines.append(f"| {rel['field_name']} | {rel['relation_type']} | {rel['related_model']} | {related_name} |")
                    
                    lines.append("")
                
                # Frontend usage notes
                lines.append("**Frontend Usage Notes:**")
                lines.append("")
                lines.append(f"- Use the model name `{model['name']}` for component naming (e.g., `{model['name']}List`, `{model['name']}Detail`)")
                lines.append(f"- Primary API endpoint will likely follow REST conventions for `{model['name'].lower()}`")
                
                # Check for special fields
                has_image = any(field['field_type'] == 'ImageField' for field in model['fields'])
                has_file = any(field['field_type'] == 'FileField' for field in model['fields'])
                has_date = any('Date' in field['field_type'] for field in model['fields'])
                
                if has_image:
                    lines.append("- Contains image fields - frontend should handle image uploads and display")
                if has_file:
                    lines.append("- Contains file fields - frontend should handle file uploads and downloads")
                if has_date:
                    lines.append("- Contains date/time fields - use appropriate date pickers and formatting")
                
                lines.append("")
        
        return lines

    def _format_serializers(self, serializers):
        """Format serializers for markdown report"""
        lines = []
        
        # Group serializers by app
        serializers_by_app = defaultdict(list)
        for serializer_key, serializer_data in serializers.items():
            app_name = serializer_key.split('.')[0]
            serializers_by_app[app_name].append((serializer_key, serializer_data))
        
        for app_name, app_serializers in serializers_by_app.items():
            lines.append(f"### App: {app_name}")
            lines.append("")
            
            for serializer_key, serializer in app_serializers:
                lines.append(f"#### {serializer['name']}")
                lines.append("")
                
                # Basic info
                lines.append(f"**Model:** {serializer['model'] or 'None'}")
                lines.append("")
                
                # Fields
                if serializer['fields']:
                    lines.append("**Fields:**")
                    for field in serializer['fields']:
                        lines.append(f"- `{field}`")
                    lines.append("")
                
                # Meta options
                if serializer['meta']:
                    lines.append("**Meta Options:**")
                    for key, value in serializer['meta'].items():
                        lines.append(f"- `{key}`: {value}")
                    lines.append("")
                
                # Frontend usage notes
                lines.append("**Frontend Usage Notes:**")
                lines.append("")
                lines.append(f"- This serializer is used for {serializer['model']} data representation")
                lines.append("- Fields listed above are directly accessible in API responses")
                
                # If no fields specified, note about __all__
                if not serializer['fields'] and serializer['meta'].get('fields') == "__all__":
                    lines.append("- Includes all fields from the model")
                
                lines.append("")
        
        return lines

    def _format_authentication(self, auth_data):
        """Format authentication details for markdown report"""
        lines = []
        
        lines.append("### Authentication Mechanisms")
        lines.append("")
        
        mechanisms = auth_data.get('mechanisms', [])
        if mechanisms:
            for mechanism in mechanisms:
                if mechanism == 'django_auth':
                    lines.append("- **Django Authentication**: Standard Django authentication system")
                elif mechanism == 'drf_auth':
                    lines.append("- **Django REST Framework Authentication**: DRF's built-in authentication")
                elif mechanism == 'drf_token':
                    lines.append("- **DRF Token Authentication**: Token-based authentication")
                    lines.append("  - Frontend should send the token in the `Authorization` header: `Token <token_value>`")
                elif mechanism == 'knox':
                    lines.append("- **Knox Token Authentication**: More secure token-based authentication")
                    lines.append("  - Frontend should send the token in the `Authorization` header: `Token <token_value>`")
                    lines.append("  - Tokens have expiry times and can be invalidated")
                elif mechanism == 'jwt':
                    lines.append("- **JWT Authentication**: JSON Web Token based authentication")
                    lines.append("  - Frontend should send the token in the `Authorization` header: `Bearer <token_value>`")
                    lines.append("  - Tokens are typically stored in localStorage or cookies")
                elif mechanism == 'oauth':
                    lines.append("- **OAuth Authentication**: OAuth-based authentication")
                    lines.append("  - Frontend will need to implement OAuth flow")
                elif mechanism == 'social_auth':
                    lines.append("- **Social Authentication**: Authentication via social providers")
                    lines.append("  - Frontend will need to implement social login buttons and flows")
                elif mechanism == 'allauth':
                    lines.append("- **Django Allauth**: Extended authentication supporting social accounts")
                elif mechanism == 'dj_rest_auth':
                    lines.append("- **dj-rest-auth**: Authentication endpoints for login, registration, password reset")
                    lines.append("  - Standard endpoints include: `/auth/login/`, `/auth/logout/`, `/auth/password/reset/`")
        else:
            lines.append("- No specific authentication mechanisms identified")
        
        lines.append("")
        
        # User model
        user_model = auth_data.get('user_model')
        if user_model:
            lines.append("### User Model")
            lines.append("")
            if auth_data.get('custom_auth'):
                lines.append(f"- **Custom User Model**: `{user_model}`")
                lines.append("  - Frontend should check for custom user fields when handling user data")
            else:
                lines.append(f"- **Default Django User Model**: `{user_model}`")
                lines.append("  - Standard fields: username, email, password, first_name, last_name, is_active, is_staff, etc.")
            lines.append("")
        
        # Frontend integration notes
        lines.append("### Frontend Integration Notes")
        lines.append("")
        lines.append("1. **Authentication Flow**:")
        
        if any(m in mechanisms for m in ['drf_token', 'knox', 'jwt']):
            lines.extend([
                "   - User submits login credentials",
                "   - Backend returns a token",
                "   - Frontend stores the token (localStorage, httpOnly cookie, etc.)",
                "   - Frontend sends the token with each request in the Authorization header",
                ""
            ])
        else:
            lines.extend([
                "   - User submits login credentials",
                "   - Backend creates a session",
                "   - Frontend stores the session cookie",
                ""
            ])
        
        lines.append("2. **Authorization**:")
        lines.append("   - Check permissions for each endpoint in the API Endpoints section above")
        lines.append("   - Handle unauthorized access gracefully with appropriate UI feedback")
        lines.append("")
        
        lines.append("3. **Common Auth Endpoints**:")
        auth_endpoints = [
            ("POST", "/api/auth/login/", "Login with username/email and password"),
            ("POST", "/api/auth/logout/", "Logout and invalidate token/session"),
            ("POST", "/api/auth/register/", "Create a new user account"),
            ("POST", "/api/auth/password/reset/", "Request a password reset email"),
            ("POST", "/api/auth/password/reset/confirm/", "Confirm password reset with token")
        ]
        
        lines.append("| Method | Endpoint | Description |")
        lines.append("| --- | --- | --- |")
        for method, endpoint, desc in auth_endpoints:
            lines.append(f"| {method} | `{endpoint}` | {desc} |")
        
        lines.append("")
        
        return lines

    def _format_issues(self, issues):
        """Format compatibility issues for markdown report"""
        lines = []
        
        # Group issues by severity
        issues_by_severity = defaultdict(list)
        for issue in issues:
            issues_by_severity[issue['severity']].append(issue)
        
        # Show errors first, then warnings, then info
        for severity in ['error', 'warning', 'info']:
            if severity in issues_by_severity:
                severity_issues = issues_by_severity[severity]
                
                lines.append(f"### {severity.upper()} Issues ({len(severity_issues)})")
                lines.append("")
                
                # Group by issue type
                issues_by_type = defaultdict(list)
                for issue in severity_issues:
                    issues_by_type[issue['issue_type']].append(issue)
                
                for issue_type, type_issues in issues_by_type.items():
                    lines.append(f"#### {issue_type.replace('_', ' ').title()} ({len(type_issues)})")
                    lines.append("")
                    
                    for issue in type_issues:
                        file_info = f" in {issue['file']}" if issue['file'] else ""
                        lines.append(f"- {issue['description']}{file_info}")
                    
                    # Add suggestions for fixing
                    if issue_type == 'serializer_model_mismatch':
                        lines.append("")
                        lines.append("**Suggestions:**")
                        lines.append("- Ensure the model is properly imported in the serializer file")
                        lines.append("- Check for typos in the model name")
                        lines.append("- Make sure the model exists in the project")
                    
                    elif issue_type == 'view_serializer_mismatch':
                        lines.append("")
                        lines.append("**Suggestions:**")
                        lines.append("- Ensure the serializer is properly imported in the view file")
                        lines.append("- Check for typos in the serializer name")
                        lines.append("- Make sure the serializer exists in the project")
                    
                    elif issue_type == 'url_view_mismatch':
                        lines.append("")
                        lines.append("**Suggestions:**")
                        lines.append("- Ensure the view is properly imported in the urls.py file")
                        lines.append("- Check for typos in the view name")
                        lines.append("- Make sure the view exists in the project")
                    
                    elif issue_type == 'naming_convention':
                        lines.append("")
                        lines.append("**Suggestions:**")
                        lines.append("- Follow Django's naming conventions for better maintainability")
                        lines.append("- Use PascalCase for model and class names")
                        lines.append("- End serializer names with 'Serializer'")
                    
                    elif issue_type == 'field_mismatch':
                        lines.append("")
                        lines.append("**Suggestions:**")
                        lines.append("- Update the serializer to only include fields that exist in the model")
                        lines.append("- Add missing fields to the model if they're needed")
                        lines.append("- Check for typos in field names")
                    
                    lines.append("")
        
        return lines

    def _format_component_mappings(self, mappings):
        """Format component mappings for markdown report"""
        lines = []
        
        for mapping_name, mapping_data in mappings.items():
            lines.append(f"### {mapping_name}")
            lines.append("")
            
            if not mapping_data:
                lines.append("No mappings found.")
                lines.append("")
                continue
            
            for source, targets in mapping_data.items():
                if isinstance(targets, list) and targets:
                    lines.append(f"- **{source}** → {', '.join(targets)}")
                elif isinstance(targets, str):
                    lines.append(f"- **{source}** → {targets}")
            
            lines.append("")
        
        return lines

    def generate_code_samples(self):
        """Generate sample code for frontend integration"""
        self.log("Generating code samples...")
        
        code_samples = {}
        
        # React component for API data fetching
        code_samples['react_api_client'] = self._generate_react_api_client()
        
        # React component for model form
        code_samples['react_model_form'] = self._generate_react_model_form()
        
        # Authentication utilities
        code_samples['auth_utilities'] = self._generate_auth_utilities()
        
        return code_samples

    def _generate_react_api_client(self):
        """Generate a React API client based on discovered endpoints"""
        # Basic structure for an API client
        api_client = """
// api.js - Auto-generated API client
import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL || '';

// Create axios instance with default config
const api = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor for adding auth token
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Response interceptor for error handling
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      // Handle unauthorized (e.g., redirect to login)
      localStorage.removeItem('token');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

// API endpoints
const apiClient = {
"""
        
        # Group endpoints by model
        endpoints_by_model = defaultdict(list)
        for endpoint in self.api_endpoints:
            if endpoint.model:
                endpoints_by_model[endpoint.model].append(endpoint)
            else:
                endpoints_by_model['other'].append(endpoint)
        
        # Generate API methods for each model
        for model, endpoints in endpoints_by_model.items():
            if model != 'other':
                # Add comment for model
                api_client += f"\n  // {model} endpoints\n"
                
                # Find common endpoints for this model
                list_endpoint = next((e for e in endpoints if e.method == 'GET' and '<id>' not in e.path), None)
                detail_endpoint = next((e for e in endpoints if e.method == 'GET' and '<id>' in e.path), None)
                create_endpoint = next((e for e in endpoints if e.method == 'POST' and '<id>' not in e.path), None)
                update_endpoint = next((e for e in endpoints if e.method in ['PUT', 'PATCH'] and '<id>' in e.path), None)
                delete_endpoint = next((e for e in endpoints if e.method == 'DELETE' and '<id>' in e.path), None)
                
                # Generate methods
                if list_endpoint:
                    model_lower = model.lower()
                    api_client += f"  get{model}List: (params = {{}}) => api.get('{list_endpoint.path}', {{ params }}),\n"
                
                if detail_endpoint:
                    path = detail_endpoint.path.replace('<id>', '${id}')
                    api_client += f"  get{model}: (id) => api.get(`{path}`),\n"
                
                if create_endpoint:
                    api_client += f"  create{model}: (data) => api.post('{create_endpoint.path}', data),\n"
                
                if update_endpoint:
                    method = update_endpoint.method.lower()
                    path = update_endpoint.path.replace('<id>', '${id}')
                    api_client += f"  update{model}: (id, data) => api.{method.lower()}(`{path}`, data),\n"
                
                if delete_endpoint:
                    path = delete_endpoint.path.replace('<id>', '${id}')
                    api_client += f"  delete{model}: (id) => api.delete(`{path}`),\n"
        
        # Add other endpoints
        if 'other' in endpoints_by_model and endpoints_by_model['other']:
            api_client += "\n  // Other endpoints\n"
            for endpoint in endpoints_by_model['other']:
                # Generate a reasonable method name
                name_parts = []
                if endpoint.name:
                    name_parts = endpoint.name.split('_')
                else:
                    # Try to derive a name from the path
                    path_parts = endpoint.path.strip('/').split('/')
                    name_parts = [p for p in path_parts if not (p.startswith('<') and p.endswith('>'))]
                
                method_name = ''.join(p.capitalize() for p in name_parts)
                method_name = endpoint.method.lower() + method_name
                
                # Handle path parameters
                path = endpoint.path
                if '<' in path and '>' in path:
                    # Replace <param> with ${param}
                    import re
                    params = re.findall(r'<([^>]+)>', path)
                    param_list = ', '.join(params)
                    for param in params:
                        path = path.replace(f'<{param}>', f'${{{param}}}')
                    api_client += f"  {method_name}: ({param_list}, data = {{}}) => api.{endpoint.method.lower()}(`{path}`, data),\n"
                else:
                    api_client += f"  {method_name}: (data = {{}}) => api.{endpoint.method.lower()}('{path}', data),\n"
        
        # Close the apiClient object and export
        api_client += """};

export default apiClient;
"""
        
        return api_client

    def _generate_react_model_form(self):
        """Generate a React form component for a model"""
        # Select a model to generate a form for
        model_info = None
        model_name = None
        
        # Try to find a suitable model
        for model_key, info in self.models.items():
            # Skip abstract or through models
            if info.meta.get('abstract') or 'through' in model_key.lower():
                continue
            model_info = info
            model_name = info.name
            break
        
        if not model_info:
            return "// No suitable models found for form generation"
        
        form_component = f"""
// {model_name}Form.js - Auto-generated form component
import React, {{ useState, useEffect }} from 'react';
import apiClient from './api';

const {model_name}Form = ({{ {model_name.lower()}Id, onSubmit, onCancel }}) => {{
  const [formData, setFormData] = useState({{}});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  // Fetch data if editing existing {model_name}
  useEffect(() => {{
    if ({model_name.lower()}Id) {{
      setLoading(true);
      apiClient.get{model_name}({model_name.lower()}Id)
        .then(response => {{
          setFormData(response.data);
          setLoading(false);
        }})
        .catch(err => {{
          setError(`Error fetching {model_name}: ${{err.message}}`);
          setLoading(false);
        }});
    }}
  }}, [{model_name.lower()}Id]);
  
  // Handle form input changes
  const handleChange = (e) => {{
    const {{ name, value, type, checked }} = e.target;
    setFormData(prev => ({{
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }}));
  }};
  
  // Handle form submission
  const handleSubmit = (e) => {{
    e.preventDefault();
    setLoading(true);
    
    const savePromise = {model_name.lower()}Id
      ? apiClient.update{model_name}({model_name.lower()}Id, formData)
      : apiClient.create{model_name}(formData);
    
    savePromise
      .then(response => {{
        setLoading(false);
        if (onSubmit) onSubmit(response.data);
      }})
      .catch(err => {{
        setError(`Error saving {model_name}: ${{err.message}}`);
        setLoading(false);
      }});
  }};
  
  if (loading) return <div>Loading...</div>;
  
  return (
    <div className="form-container">
      <h2>{{({model_name.lower()}Id ? 'Edit' : 'Create')}} {model_name}</h2>
      
      {{error && <div className="error-message">{{error}}</div>}}
      
      <form onSubmit={handleSubmit}>
"""
        
        # Generate form fields based on model fields
        for field in model_info.fields:
            field_name = field.name
            field_type = field.field_type.lower()
            
            # Skip automatic fields
            if field_name in ['id', 'created_at', 'updated_at', 'created', 'modified']:
                continue
            
            # Generate appropriate form control based on field type
            if field_type in ['charfield', 'emailfield', 'slugfield', 'urlfield']:
                form_component += f"""
        <div className="form-group">
          <label htmlFor="{field_name}">{field_name.replace('_', ' ').title()}</label>
          <input
            type="text"
            id="{field_name}"
            name="{field_name}"
            value={{formData.{field_name} || ''}}
            onChange={{handleChange}}
            required={{{'true' if field.options.get('blank') is not True else 'false'}}}
          />
        </div>
"""
            elif field_type == 'textfield':
                form_component += f"""
        <div className="form-group">
          <label htmlFor="{field_name}">{field_name.replace('_', ' ').title()}</label>
          <textarea
            id="{field_name}"
            name="{field_name}"
            value={{formData.{field_name} || ''}}
            onChange={{handleChange}}
            required={{{'true' if field.options.get('blank') is not True else 'false'}}}
            rows="4"
          ></textarea>
        </div>
"""
            elif field_type in ['integerfield', 'positiveintegerfield', 'positivesmallintegerfield']:
                form_component += f"""
        <div className="form-group">
          <label htmlFor="{field_name}">{field_name.replace('_', ' ').title()}</label>
          <input
            type="number"
            id="{field_name}"
            name="{field_name}"
            value={{formData.{field_name} || ''}}
            onChange={{handleChange}}
            required={{{'true' if field.options.get('blank') is not True else 'false'}}}
          />
        </div>
"""
            elif field_type == 'booleanfield':
                form_component += f"""
        <div className="form-group checkbox">
          <label htmlFor="{field_name}">
            <input
              type="checkbox"
              id="{field_name}"
              name="{field_name}"
              checked={{!!formData.{field_name}}}
              onChange={{handleChange}}
            />
            {field_name.replace('_', ' ').title()}
          </label>
        </div>
"""
            elif field_type in ['datefield', 'datetimefield']:
                form_component += f"""
        <div className="form-group">
          <label htmlFor="{field_name}">{field_name.replace('_', ' ').title()}</label>
          <input
            type="{{'datetime-local' if field_type == 'datetimefield' else 'date'}}"
            id="{field_name}"
            name="{field_name}"
            value={{formData.{field_name} || ''}}
            onChange={{handleChange}}
            required={{{'true' if field.options.get('blank') is not True else 'false'}}}
          />
        </div>
"""
            elif field_type in ['foreignkey', 'onetoonefield', 'manytomanyfield']:
                related_model = "Related Model"
                for rel in model_info.relationships:
                    if rel['field_name'] == field_name:
                        related_model = rel['related_model']
                        break
                
                form_component += f"""
        <div className="form-group">
          <label htmlFor="{field_name}">{field_name.replace('_', ' ').title()} ({related_model})</label>
          {{/* This would be replaced with a select dropdown populated from API */}}
          <select
            id="{field_name}"
            name="{field_name}"
            value={{formData.{field_name} || ''}}
            onChange={{handleChange}}
            required={{{'true' if field.options.get('blank') is not True else 'false'}}}
          >
            <option value="">Select {related_model}</option>
            {{/* Options would be loaded dynamically */}}
          </select>
        </div>
"""
            elif field_type in ['filefield', 'imagefield']:
                form_component += f"""
        <div className="form-group">
          <label htmlFor="{field_name}">{field_name.replace('_', ' ').title()}</label>
          {{/* File uploads require special handling with FormData */}}
          <input
            type="file"
            id="{field_name}"
            name="{field_name}"
            onChange={{(e) => {{
              // File upload would need special handling
              console.log('File selected:', e.target.files[0]);
              // You'd need to use FormData for the actual upload
            }}}}
            required={{{'true' if field.options.get('blank') is not True else 'false'}}}
          />
          {{formData.{field_name} && (
            <div className="file-preview">
              <span>Current file: {{formData.{field_name}}}</span>
            </div>
          )}}
        </div>
"""
            else:
                # Default to text input for other field types
                form_component += f"""
        <div className="form-group">
          <label htmlFor="{field_name}">{field_name.replace('_', ' ').title()} ({field_type})</label>
          <input
            type="text"
            id="{field_name}"
            name="{field_name}"
            value={{formData.{field_name} || ''}}
            onChange={{handleChange}}
            required={{{'true' if field.options.get('blank') is not True else 'false'}}}
          />
        </div>
"""
        
        # Form submission buttons
        form_component += """
        <div className="form-actions">
          <button type="submit" className="btn btn-primary" disabled={loading}>
            {loading ? 'Saving...' : 'Save'}
          </button>
          {onCancel && (
            <button type="button" className="btn btn-secondary" onClick={onCancel}>
              Cancel
            </button>
          )}
        </div>
      </form>
    </div>
  );
};

export default """ + model_name + "Form;\n"
        
        return form_component

    def _generate_auth_utilities(self):
        """Generate authentication utilities based on detected authentication mechanism"""
        # Analyze authentication to determine utility functions
        auth_data = self.analyze_authentication()
        mechanisms = auth_data.get('mechanisms', [])
        
        is_token_based = any(m in mechanisms for m in ['drf_token', 'knox', 'jwt'])
        is_jwt = 'jwt' in mechanisms
        
        auth_utilities = """
// auth.js - Authentication utilities
import apiClient from './api';

// Storage keys
const TOKEN_KEY = 'auth_token';
const USER_KEY = 'auth_user';
"""
        
        if is_token_based:
            token_prefix = 'Bearer ' if is_jwt else 'Token '
            
            auth_utilities += f"""
// Login user and store token
export const login = async (username, password) => {{
  try {{
    const response = await apiClient.login({{ username, password }});
    
    // Extract token from response based on API format
    const token = response.data.{'token' if not is_jwt else 'access'};
    
    if (token) {{
      // Store token
      localStorage.setItem(TOKEN_KEY, token);
      
      // Store user info
      const user = response.data.user || {{
        username,
        // Add other user fields available from response
      }};
      localStorage.setItem(USER_KEY, JSON.stringify(user));
      
      // Set token in API client
      apiClient.setAuthToken(token);
      
      return user;
    }}
    throw new Error('Token not found in response');
  }} catch (error) {{
    console.error('Login error:', error);
    throw error;
  }}
}};

// Logout user
export const logout = async () => {{
  try {{
    // Call logout endpoint if available
    if (isAuthenticated()) {{
      await apiClient.logout();
    }}
  }} catch (error) {{
    console.error('Logout error:', error);
  }} finally {{
    // Always clear local storage
    localStorage.removeItem(TOKEN_KEY);
    localStorage.removeItem(USER_KEY);
    
    // Remove token from API client
    apiClient.setAuthToken(null);
  }}
}};

// Check if user is authenticated
export const isAuthenticated = () => {{
  const token = localStorage.getItem(TOKEN_KEY);
  return !!token;
}};

// Get current user
export const getCurrentUser = () => {{
  try {{
    const user = localStorage.getItem(USER_KEY);
    return user ? JSON.parse(user) : null;
  }} catch (error) {{
    console.error('Error getting current user:', error);
    return null;
  }}
}};

// Get auth header
export const getAuthHeader = () => {{
  const token = localStorage.getItem(TOKEN_KEY);
  return token ? {{ Authorization: `{token_prefix}${{token}}` }} : {{}};
}};

// Register new user
export const register = async (userData) => {{
  try {{
    const response = await apiClient.register(userData);
    return response.data;
  }} catch (error) {{
    console.error('Registration error:', error);
    throw error;
  }}
}};

// Password reset request
export const requestPasswordReset = async (email) => {{
  try {{
    const response = await apiClient.requestPasswordReset({{ email }});
    return response.data;
  }} catch (error) {{
    console.error('Password reset request error:', error);
    throw error;
  }}
}};
"""
        else:
            # Session-based authentication
            auth_utilities += """
// Session-based login
export const login = async (username, password) => {
  try {
    const response = await apiClient.login({ username, password });
    
    // Store user info
    const user = response.data.user || { username };
    localStorage.setItem(USER_KEY, JSON.stringify(user));
    
    return user;
  } catch (error) {
    console.error('Login error:', error);
    throw error;
  }
};

// Logout user
export const logout = async () => {
  try {
    await apiClient.logout();
  } catch (error) {
    console.error('Logout error:', error);
  } finally {
    localStorage.removeItem(USER_KEY);
  }
};

// Check if user is authenticated
export const isAuthenticated = async () => {
  try {
    // With session auth, we need to check with the server
    const response = await apiClient.me();
    return !!response.data;
  } catch (error) {
    return false;
  }
};

// Get current user
export const getCurrentUser = async () => {
  try {
    // Try to get from local storage first
    const cachedUser = localStorage.getItem(USER_KEY);
    
    if (cachedUser) {
      return JSON.parse(cachedUser);
    }
    
    // Otherwise fetch from API
    const response = await apiClient.me();
    const user = response.data;
    
    if (user) {
      localStorage.setItem(USER_KEY, JSON.stringify(user));
    }
    
    return user;
  } catch (error) {
    console.error('Error getting current user:', error);
    return null;
  }
};

// Register new user
export const register = async (userData) => {
  try {
    const response = await apiClient.register(userData);
    return response.data;
  } catch (error) {
    console.error('Registration error:', error);
    throw error;
  }
};

// Password reset request
export const requestPasswordReset = async (email) => {
  try {
    const response = await apiClient.requestPasswordReset({ email });
    return response.data;
  } catch (error) {
    console.error('Password reset request error:', error);
    throw error;
  }
};
"""
        
        # Add React auth context
        auth_utilities += """
// React authentication context
import React, { createContext, useState, useContext, useEffect } from 'react';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Check authentication status on mount
    const checkAuth = async () => {
      try {
        if (isAuthenticated()) {
          const userData = getCurrentUser();
          setUser(userData);
        }
      } catch (error) {
        console.error('Auth check error:', error);
      } finally {
        setLoading(false);
      }
    };
    
    checkAuth();
  }, []);
  
  const authContextValue = {
    user,
    isAuthenticated: !!user,
    login: async (username, password) => {
      const userData = await login(username, password);
      setUser(userData);
      return userData;
    },
    logout: async () => {
      await logout();
      setUser(null);
    },
    register: async (userData) => {
      const result = await register(userData);
      return result;
    },
    loading
  };
  
  return (
    <AuthContext.Provider value={authContextValue}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => useContext(AuthContext);
"""
        
        return auth_utilities

def main():
    """Main function to run the analyzer"""
    parser = argparse.ArgumentParser(description="Analyze Django backend for frontend integration")
    parser.add_argument('--backend_path', type=str, default='.',
                        help='Path to the Django backend directory')
    parser.add_argument('--output_file', type=str, default='backend_analysis_report.md',
                        help='Output file path')
    parser.add_argument('--output_format', type=str, default='markdown', choices=['markdown', 'json'],
                        help='Output format (markdown or json)')
    parser.add_argument('--verbose', action='store_true',
                        help='Enable verbose output')
    parser.add_argument('--include_code_samples', action='store_true',
                        help='Include sample code in the report')
    parser.add_argument('--exclude_apps', type=str, nargs='+', default=[],
                        help='List of app names to exclude from analysis')
    
    args = parser.parse_args()
    
    print(f"Analyzing Django backend at: {args.backend_path}")
    analyzer = BackendAnalyzer(args.backend_path, args.verbose)
    
    analysis_data = analyzer.analyze()
    
    if args.include_code_samples:
        code_samples = analyzer.generate_code_samples()
        analysis_data['code_samples'] = code_samples
    
    report = analyzer.generate_report(analysis_data, args.output_format)
    
    with open(args.output_file, 'w') as f:
        f.write(report)
    
    print(f"Report generated: {args.output_file}")

if __name__ == "__main__":
    main()